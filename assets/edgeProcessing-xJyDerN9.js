import{e as Ot}from"./deduplicate-BqEut_S4.js";import{H as F}from"./InterleavedLayout-CDMBbzCt.js";import{e as l}from"./VertexAttribute-BlT9lbVY.js";import{C as V}from"./enums-BlUEVwJR.js";import{t as St}from"./VertexElementDescriptor-BOD-G50G.js";import{ab as Et,cR as At,b6 as Nt,b7 as T,ja as Tt,c7 as tt,iY as wt,gO as H,cN as rt,b3 as K,iW as $t,k4 as yt,b4 as dt,cO as it,gq as ht}from"./index-C74WJ1Ej.js";function et(t,e=0){const s=t.stride;return Array.from(t.fields.keys()).map(o=>{var a;const r=t.fields.get(o),c=r.constructor.ElementCount,N=Mt(r.constructor.ElementType),d=r.offset,g=((a=r.optional)==null?void 0:a.glNormalized)??!1;return new St(o,c,N,d,s,g,e)})}function Mt(t){const e=vt[t];if(e)return e;throw new Error("BufferType not supported in WebGL")}const vt={u8:V.UNSIGNED_BYTE,u16:V.UNSIGNED_SHORT,u32:V.UNSIGNED_INT,i8:V.BYTE,i16:V.SHORT,i32:V.INT,f32:V.FLOAT};function Y(t,e,s,o,r,c=2){const N=1/(Math.abs(s)+Math.abs(o)+Math.abs(r)),d=s*N,g=o*N,a=r<=0?(d>=0?1:-1)*(1-Math.abs(g)):d,p=r<=0?(g>=0?1:-1)*(1-Math.abs(d)):g,m=e*c;t[m]=at(a),t[m+1]=at(p)}function at(t){return Et(Math.round(32767*t),-32767,32767)}const Rt=F().vec3f(l.POSITION).u16(l.COMPONENTINDEX).freeze(),Pt=F().vec2u8(l.SIDENESS).freeze();et(Pt);const j=F().vec3f(l.POSITION0).vec3f(l.POSITION1).vec2i16(l.NORMALCOMPRESSED).u16(l.COMPONENTINDEX).u8(l.VARIANTOFFSET,{glNormalized:!0}).u8(l.VARIANTSTROKE).u8(l.VARIANTEXTENSION,{glNormalized:!0}).freeze(),J=F().vec3f(l.POSITION0).vec3f(l.POSITION1).vec2i16(l.NORMALCOMPRESSED).vec2i16(l.NORMAL2COMPRESSED).u16(l.COMPONENTINDEX).u8(l.VARIANTOFFSET,{glNormalized:!0}).u8(l.VARIANTSTROKE).u8(l.VARIANTEXTENSION,{glNormalized:!0}).freeze();l.POSITION0,l.POSITION1,l.COMPONENTINDEX,l.VARIANTOFFSET,l.VARIANTSTROKE,l.VARIANTEXTENSION,l.NORMALCOMPRESSED,l.NORMAL2COMPRESSED,l.SIDENESS;function ct(t,e,s){const o=e/3,r=new Uint32Array(s+1),c=new Uint32Array(s+1),N=(n,i)=>{n<i?r[n+1]++:c[i+1]++};for(let n=0;n<o;n++){const i=t[3*n],f=t[3*n+1],u=t[3*n+2];N(i,f),N(f,u),N(u,i)}let d=0,g=0;for(let n=0;n<s;n++){const i=r[n+1],f=c[n+1];r[n+1]=d,c[n+1]=g,d+=i,g+=f}const a=new Uint32Array(6*o),p=r[s],m=(n,i,f)=>{if(n<i){const u=r[n+1]++;a[2*u]=i,a[2*u+1]=f}else{const u=c[i+1]++;a[2*p+2*u]=n,a[2*p+2*u+1]=f}};for(let n=0;n<o;n++){const i=t[3*n],f=t[3*n+1],u=t[3*n+2];m(i,f,n),m(f,u,n),m(u,i,n)}const E=(n,i)=>{const f=2*n,u=i-n;for(let S=1;S<u;S++){const $=a[f+2*S],M=a[f+2*S+1];let h=S-1;for(;h>=0&&a[f+2*h]>$;h--)a[f+2*h+2]=a[f+2*h],a[f+2*h+3]=a[f+2*h+1];a[f+2*h+2]=$,a[f+2*h+3]=M}};for(let n=0;n<s;n++)E(r[n],r[n+1]),E(p+c[n],p+c[n+1]);const P=new Int32Array(3*o),B=(n,i)=>n===t[3*i]?0:n===t[3*i+1]?1:n===t[3*i+2]?2:-1,w=(n,i)=>{const f=B(n,i);P[3*i+f]=-1},_=(n,i,f,u)=>{const S=B(n,i);P[3*i+S]=u;const $=B(f,u);P[3*u+$]=i};for(let n=0;n<s;n++){let i=r[n];const f=r[n+1];let u=c[n];const S=c[n+1];for(;i<f&&u<S;){const $=a[2*i],M=a[2*p+2*u];$===M?(_(n,a[2*i+1],M,a[2*p+2*u+1]),i++,u++):$<M?(w(n,a[2*i+1]),i++):(w(M,a[2*p+2*u+1]),u++)}for(;i<f;)w(n,a[2*i+1]),i++;for(;u<S;)w(a[2*p+2*u],a[2*p+2*u+1]),u++}return P}const q=.7;let gt=class{updateSettings(e){this.settings=e,this._edgeHashFunction=e.reducedPrecision?bt:Vt}write(e,s,o){z.seed=this._edgeHashFunction(o);const r=z.getIntRange(0,255),c=z.getIntRange(0,this.settings.variants-1),N=z.getFloat(),d=255*(.5*xt(-(1-Math.min(N/q,1))+Math.max(0,N-q)/(1-q),1.2)+.5);e.position0.setVec(s,o.position0),e.position1.setVec(s,o.position1),e.componentIndex.set(s,o.componentIndex),e.variantOffset.set(s,r),e.variantStroke.set(s,c),e.variantExtension.set(s,d)}};const v=new Float32Array(6),R=new Uint32Array(v.buffer),C=new Uint32Array(1);function Vt(t){return v[0]=t.position0[0],v[1]=t.position0[1],v[2]=t.position0[2],v[3]=t.position1[0],v[4]=t.position1[1],v[5]=t.position1[2],C[0]=31*(31*(31*(31*(31*(166811+R[0])+R[1])+R[2])+R[3])+R[4])+R[5],C[0]}function bt(t){const e=v;e[0]=D(t.position0[0]),e[1]=D(t.position0[1]),e[2]=D(t.position0[2]),e[3]=D(t.position1[0]),e[4]=D(t.position1[1]),e[5]=D(t.position1[2]),C[0]=5381;for(let s=0;s<R.length;s++)C[0]=31*C[0]+R[s];return C[0]}const lt=1e4;function D(t){return Math.round(t*lt)/lt}function xt(t,e){return Math.abs(t)**e*Math.sign(t)}let Q=class{constructor(){this._commonWriter=new gt}updateSettings(e){this._commonWriter.updateSettings(e)}allocate(e){return j.createBuffer(e)}write(e,s,o){this._commonWriter.write(e,s,o),At(L,o.faceNormal0,o.faceNormal1),Nt(L,L);const{typedBuffer:r,typedBufferStride:c}=e.normalCompressed;Y(r,s,L[0],L[1],L[2],c)}};Q.Layout=j,Q.glLayout=et(j,1);let Z=class{constructor(){this._commonWriter=new gt}updateSettings(e){this._commonWriter.updateSettings(e)}allocate(e){return J.createBuffer(e)}write(e,s,o){this._commonWriter.write(e,s,o);{const{typedBuffer:r,typedBufferStride:c}=e.normalCompressed;Y(r,s,o.faceNormal0[0],o.faceNormal0[1],o.faceNormal0[2],c)}{const{typedBuffer:r,typedBufferStride:c}=e.normal2Compressed;Y(r,s,o.faceNormal1[0],o.faceNormal1[1],o.faceNormal1[2],c)}}};Z.Layout=J,Z.glLayout=et(J,1);const L=T(),z=new Tt;class Dt{constructor(){this.position0=T(),this.position1=T(),this.faceNormal0=T(),this.faceNormal1=T(),this.componentIndex=0,this.cosAngle=0}}const k=-1;function Lt(t,e,s){const o=t.vertices.position,r=t.vertices.componentIndex,c=O.position0,N=O.position1,d=O.faceNormal0,g=O.faceNormal1,{edges:a,normals:p}=_t(t),m=a.length/4,E=e.allocate(m);let P=0;const B=m,w=s==null?void 0:s.allocate(B);let _=0,n=0,i=0;U.length=0;for(let h=0;h<m;++h){const y=4*h;o.getVec(a.data[y],c),o.getVec(a.data[y+1],N);const x=U.pushNew();x.index=4*h,x.length=wt(c,N)}U.sort((h,y)=>y.length-h.length);const f=new Array,u=new Array;U.forAll(({length:h,index:y})=>{const x=a.data[y],It=a.data[y+1],nt=a.data[y+2],st=a.data[y+3],ot=st===k;if(o.getVec(x,c),o.getVec(It,N),ot){const A=3*nt;H(d,p.data[A],p.data[A+1],p.data[A+2]),rt(g,d),O.componentIndex=r.get(x),O.cosAngle=K(d,g)}else{let A=3*nt;if(H(d,p.data[A],p.data[A+1],p.data[A+2]),A=3*st,H(g,p.data[A],p.data[A+1],p.data[A+2]),O.componentIndex=r.get(x),O.cosAngle=K(d,g),Ft(O,Wt))return;O.cosAngle<-.9999&&rt(g,d)}n+=h,i++,ot||Ct(O,kt)?(e.write(E,P++,O),f.push(h)):Bt(O,mt)&&(w&&s&&s.write(w,_++,O),u.push(h))});const S=new Float32Array(f.reverse()),$=new Float32Array(u.reverse()),M=w&&s?{instancesData:w.slice(0,_),lodInfo:{lengths:$}}:void 0;return{regular:{instancesData:E.slice(0,P),lodInfo:{lengths:S}},silhouette:M,averageEdgeLength:n/i}}function Ct(t,e){return t.cosAngle<e}function Ft(t,e){return t.cosAngle>e}function Bt(t,e){const s=$t(t.cosAngle);return yt(ut,t.position1,t.position0),s*(K(dt(Ut,t.faceNormal0,t.faceNormal1),ut)>0?-1:1)>e}function _t(t){const e=t.faces.length/3,s=t.faces,o=t.neighbors,r=t.vertices.position;I.length=G.length=0;for(let c=0;c<e;c++){const N=3*c,d=o[N],g=o[N+1],a=o[N+2],p=s[N],m=s[N+1],E=s[N+2];r.getVec(p,b),r.getVec(m,W),r.getVec(E,X),it(W,W,b),it(X,X,b),dt(b,W,X),Nt(b,b),G.pushArray(b),(d===k||p<m)&&(I.push(p),I.push(m),I.push(c),I.push(d)),(g===k||m<E)&&(I.push(m),I.push(E),I.push(c),I.push(g)),(a===k||E<p)&&(I.push(E),I.push(p),I.push(c),I.push(a))}return{edges:I,normals:G}}class zt{constructor(){this.index=0,this.length=0}}const U=new tt({allocator:t=>t||new zt,deallocator:null}),I=new tt({deallocator:null}),G=new tt({deallocator:null}),O=new Dt,Ut=T(),ut=T(),b=T(),W=T(),X=T(),mt=ht(4),Wt=Math.cos(mt),Xt=ht(35),kt=Math.cos(Xt);function ne(t){const e=Ht(t.data,t.skipDeduplicate,t.indices,t.indicesLength);return ft.updateSettings(t.writerSettings),pt.updateSettings(t.writerSettings),Lt(e,ft,pt)}function Ht(t,e,s,o){if(e){const N=ct(s,o,t.count);return new qt(s,o,N,t)}const r=Ot(t.buffer,t.stride/4,{originalIndices:s,originalIndicesLength:o}),c=ct(r.indices,o,r.uniqueCount);return{faces:r.indices,facesLength:r.indices.length,neighbors:c,vertices:Rt.createView(r.buffer)}}class qt{constructor(e,s,o,r){this.faces=e,this.facesLength=s,this.neighbors=o,this.vertices=r}}const ft=new Q,pt=new Z,se=F().vec3f(l.POSITION0).vec3f(l.POSITION1),oe=F().vec3f(l.POSITION0).vec3f(l.POSITION1).u16(l.COMPONENTINDEX);export{Rt as E,se as d,ne as f,oe as m,Lt as p,Ht as u};
